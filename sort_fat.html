<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
        <title>Kevin Boone: Sorting files and directories on a FAT-formatted USB memory stick</title>
        <link rel="shortcut icon" href="https://kevinboone.me/img/favicon.ico">
        <meta name="msvalidate.01" content="894212EEB3A89CC8B4E92780079B68E9"/>
        <meta name="google-site-verification" content="DXS4cMAJ8VKUgK84_-dl0J1hJK9HQdYU4HtimSr_zLE" />
        <meta name="description" content="%%DESC%%">
        <meta name="author" content="Kevin Boone">
        <meta name="viewport" content="width=device-width; initial-scale=1; maximum-scale=1">
        <link rel="stylesheet" href="css/main.css">
</head>


<body>

<div id="myname">
Kevin Boone
</div>

<div id="menu">
 <a class="menu_entry" href="index.html">Home</a>
 <a class="menu_entry" href="contact.html">Contact</a>
 <a class="menu_entry" href="cv.html">CV</a>
 <a class="menu_entry" href="software.html">Software</a>
 <a class="menu_entry" href="articles.html">Articles</a>
 <form id="search_form" method="get" action="https://duckduckgo.com/" target="_blank"><input type="text" name="q" placeholder="Search" size="5" id="search_input" /><button type="submit" id="search_submit">&#128269;</button><input type="hidden" name="sites" value="kevinboone.me" /><input type="hidden" name="kn" value="1" /></form>
</div>

<div id="content">





<h1>Sorting files and directories on a FAT-formatted USB memory stick</h1>
<p>
<img class="article-top-image" src="img/tux_disk.png" alt="disk logo"/>
I recently bought a Leak CD player. It has a USB slot, and can play
audio files from a FAT-formatted memory stick. The radio in my car
has a similar feature. By using a folder for each music album, it's
relatively easy to provide a large music collection on a single
USB stick.
</p>
<p>
Both the Leak CD player and my car radio have the same limitation:
they don't sort the files or folders on the memory device. This
makes it very difficult to find a particular album to play and, even then,
the tracks aren't always played in the right order, even if the files are
named methodically (e.g., <code>01 foo.mp3</code>, <code>02 bar.mp3</code>...)
</p>
<p>
A simple way to overcome this limitation is to copy all the audio files
and folders to a local folder first, and then copy the whole folder 
structure
to the memory stick using a utility that can copy in alphanumerical
order (e.g., <code>rsync</code>). However, a large memory
stick can take hours to fill and, even then, it's impossible to update
its contents later without breaking the ordering. What is needed is 
a way to sort
the directories in the FAT filesystem in place, without moving any
files. The method has to be able to cope with the fact that files
and directories might be hierarchically nested. That is, files have
to be sorted within their directories, not globally. 
</p>

<h2>Basic principle</h2>
<p>
The process I describe in this article is based on 
a utility called <a href="https://www.luisrios.eti.br/public/en_us/projects/yafs/index.jsp" target="_blank">YAFS</a>, maintained by
Luis Rios. YAFS can read and write the structure of a FAT 
filesystem as an XML file. Each entry in the XML file contains, along with
the long and short names of each file or directory, an 
<code>order</code> attribute. This is a number that represents the
sequence of files in the filesystem.
</p>
<p>
We can change the ordering of files and folders by changing the
<code>order</code> attribute in the XML, and writing the XML back
to the filesystem using <code>yafs</code>. However, while it's 
conceptually 
simple, it's actually rather awkward to rewrite just the 
attributes in the XML file. 
We can't just hack the XML about using <code>sed</code> and <code>awk</code>,
because it is hierarchically structured. 
</p>
<p>
My approach, therefore, is to use <code>xsltproc</code> with a
stylesheet transformation. This process reads the XML generated by
<code>yafs</code>, and writes a new XML file with
exactly the same file/directory details, but with each directory's contents
sorted by alphanumeric order, and with new <code>order</code> 
attributes. 
</p>
<p>
Because the entries have been sorted, the <code>order</code> attribute
for each file or folder is easy to derive:
it is taken from the position of the
entry within its parent element in the XML. XSLT has a built-in function
<code>position()</code> that returns this sequence number.
This approach is a little ugly,
because the positions of the files in a folder don't start at "1" -- 
entries "1" and
"2" are the long and short names of the folder. Still,
nothing but <code>yafs</code> will ever see these numbers so,
provided they are sequential, it doesn't matter what they actually are.
</p>
<p>
In summary, the basic principle is:
</p>
<p>
1. Read the FAT directory structure using <code>yafs -r</code>.
</p>
<p>
2. Sort the entries in the resulting XML file using <code>xsltproc</code>
and a stylesheet.
</p>
<p>
3. Write the new layout from the XML file using <code>yafs -w</code>.
</p>
<p>
On the YAFS website there is a link to a pre-compiled 
<a href="https://www.luisrios.eti.br/public/en_us/projects/yafs/">Linux binary</a>, and 
a reference to the source code. There's also a Windows binary, but I'm
not sure how you'd run <code>xsltproc</code> on Windows. I guess you could
use the Windows Subsystem for Linux or, on earlier systems, Cygwin. 
Building from source (on Linux) is
not difficult, but I found that the binary worked for
me. 
</p>
<p>
The set-up for the procedure in this article is a little tedious. However,
once it's done, the actual sorting just involves three Linux commands,
which could easily be scripted. Even with a 64Gb memory stick, the
sorting operation takes under a second on my system.
</p>

<h2>Preparation -- pre-compiled Linux binary</h2>
<p>
Unpack the binary distribution to any convenient directory.
Then copy the executable and the XSD schema file to any
convenient, permanent location. I'm using <code>/usr/bin</code>
but any directory will be fine. The application expects to be able
to find the XSD schema in the same directory as the binary.
You'll have to invoke the binary using its full pathname, so it doesn't
really need to be in a location in the <code>$PATH</code>. 
</p>

<pre class="codeblock">
$ sudo cp -p yafs/yafs /usr/bin/
$ sudo cp yafs/fat_file_system_tree.xsd /usr/bin/
</pre>

<h2>Preparation -- building from source</h2>

<p>
This step is only necessary if the binary doesn't work, or you need
to modify something.
Unpack the source bundle into any convenient directory.
</p>

<pre class="codeblock">
Install Xerces-C library development header 
(method depends on the distribution)

$ sudo dnf install xerces-c-devel

Compile

$ mkdir bin deps
$ make -f makefile_unix

Copy the binary and schema to /usr/bin

$ sudo cp -p bin/yafs /usr/bin/
$ sudo cp bin/fat_file_system_tree.xsd /usr/bin/
</pre>

<p>
As with the binary bundle, the executable and the XSD schema need
to be installed in the same directory.
</p>

<h2>Preparation -- source and binary</h2>

<p>
Cut and paste the following XSLT stylesheet to a text file, and save
it as (for example) <code>yafs.xsl</code>
</p>

<pre class="codeblock"><b><font color="#0000FF">&lt;xsl:stylesheet</font></b> <font color="#009900">version</font><font color="#990000">=</font><font color="#FF0000">"1.0"</font> <font color="#009900">xmlns:xsl</font><font color="#990000">=</font><font color="#FF0000">"http://www.w3.org/1999/XSL/Transform"</font><b><font color="#0000FF">&gt;</font></b>
  <b><font color="#0000FF">&lt;xsl:output</font></b> <font color="#009900">indent</font><font color="#990000">=</font><font color="#FF0000">"yes"</font><b><font color="#0000FF">/&gt;</font></b>
  <b><font color="#0000FF">&lt;xsl:strip-space</font></b> <font color="#009900">elements</font><font color="#990000">=</font><font color="#FF0000">"*"</font><b><font color="#0000FF">/&gt;</font></b>

  <b><font color="#0000FF">&lt;xsl:template</font></b> <font color="#009900">match</font><font color="#990000">=</font><font color="#FF0000">"node()|@*"</font><b><font color="#0000FF">&gt;</font></b>
    <b><font color="#0000FF">&lt;xsl:copy&gt;</font></b>
      <b><font color="#0000FF">&lt;xsl:apply-templates</font></b> <font color="#009900">select</font><font color="#990000">=</font><font color="#FF0000">"node()|@*"</font><b><font color="#0000FF">/&gt;</font></b>
    <b><font color="#0000FF">&lt;/xsl:copy&gt;</font></b>
  <b><font color="#0000FF">&lt;/xsl:template&gt;</font></b>

  <b><font color="#0000FF">&lt;xsl:template</font></b> <font color="#009900">match</font><font color="#990000">=</font><font color="#FF0000">"root"</font><b><font color="#0000FF">&gt;</font></b>
    <b><font color="#0000FF">&lt;root&gt;</font></b>
      <b><font color="#0000FF">&lt;xsl:apply-templates&gt;</font></b>
        <b><font color="#0000FF">&lt;xsl:sort</font></b> <font color="#009900">select</font><font color="#990000">=</font><font color="#FF0000">"long_name"</font><b><font color="#0000FF">/&gt;</font></b>
      <b><font color="#0000FF">&lt;/xsl:apply-templates&gt;</font></b>
    <b><font color="#0000FF">&lt;/root&gt;</font></b>
  <b><font color="#0000FF">&lt;/xsl:template&gt;</font></b>

  <b><font color="#0000FF">&lt;xsl:template</font></b> <font color="#009900">match</font><font color="#990000">=</font><font color="#FF0000">"directory"</font><b><font color="#0000FF">&gt;</font></b>
    <b><font color="#0000FF">&lt;directory&gt;</font></b>
      <b><font color="#0000FF">&lt;xsl:attribute</font></b> <font color="#009900">name</font><font color="#990000">=</font><font color="#FF0000">"order"</font><b><font color="#0000FF">&gt;</font></b> <b><font color="#0000FF">&lt;xsl:value-of</font></b> <font color="#009900">select</font><font color="#990000">=</font><font color="#FF0000">"position()"</font><b><font color="#0000FF">/&gt;&lt;/xsl:attribute&gt;</font></b>
      <b><font color="#0000FF">&lt;xsl:apply-templates&gt;</font></b>
        <b><font color="#0000FF">&lt;xsl:sort</font></b> <font color="#009900">select</font><font color="#990000">=</font><font color="#FF0000">"long_name"</font><b><font color="#0000FF">/&gt;</font></b>
      <b><font color="#0000FF">&lt;/xsl:apply-templates&gt;</font></b>
    <b><font color="#0000FF">&lt;/directory&gt;</font></b>
  <b><font color="#0000FF">&lt;/xsl:template&gt;</font></b>

  <b><font color="#0000FF">&lt;xsl:template</font></b> <font color="#009900">match</font><font color="#990000">=</font><font color="#FF0000">"file"</font><b><font color="#0000FF">&gt;</font></b>
    <b><font color="#0000FF">&lt;file&gt;</font></b>
      <b><font color="#0000FF">&lt;xsl:attribute</font></b> <font color="#009900">name</font><font color="#990000">=</font><font color="#FF0000">"order"</font><b><font color="#0000FF">&gt;</font></b> <b><font color="#0000FF">&lt;xsl:value-of</font></b> <font color="#009900">select</font><font color="#990000">=</font><font color="#FF0000">"position()"</font><b><font color="#0000FF">/&gt;&lt;/xsl:attribute&gt;</font></b>
      <b><font color="#0000FF">&lt;xsl:apply-templates&gt;</font></b>
        <b><font color="#0000FF">&lt;xsl:sort</font></b> <font color="#009900">select</font><font color="#990000">=</font><font color="#FF0000">"long_name"</font><b><font color="#0000FF">/&gt;</font></b>
      <b><font color="#0000FF">&lt;/xsl:apply-templates&gt;</font></b>      
    <b><font color="#0000FF">&lt;/file&gt;</font></b>
  <b><font color="#0000FF">&lt;/xsl:template&gt;</font></b>

<b><font color="#0000FF">&lt;/xsl:stylesheet&gt;</font></b>
</pre>

<p>
Copy this file to some convenient, permanent location, such as 
<code>/usr/share</code>.
</p>

<pre class="codeblock">
$ sudo cp yafs.xsl /usr/share 
</pre>

<h2>Usage</h2>

<p>
1. Insert or connect the device containing the FAT filesystem.
Get the entry in <code>/dev/</code> that represents this device,
perhaps by looking at the output from <code>dmesg</code>.
</p> 

<p>
2. Ensure that the device is unmounted. Many Linux systems auto-mount
removeable devices when they are connected. You can unmount it using
the <code>umount</code> command, or from a file manager -- details depend
on the distribution. In fact, I've found that the procedure works with
the device mounted, but this isn't something that should be relied on.
</p> 

<p>
3. Get the existing filesystem layout as an XML file. I've called it
<code>fat.xml</code> here, but the name is arbitrary.
</p>
<pre class="codeblock">
$ sudo /usr/bin/yafs -d /dev/sda1 -r -f fat.xml
</pre>
<p>
Note that the input to <code>yafs</code> is a partition containing
a FAT filesystem (<code>sda1</code>), not the block device <code>sda</code>. 
</p> 

<p>
4. Sort the entries in the XML file into alphanumerical order
using the XSLT stylesheet. Save the output in a new XML file,
which I've called <code>fat_sorted.xml</code> here.
</p> 
<pre class="codeblock">
$ xsltproc /usr/share/yafs.xsl fat.xml > fat_sorted.xml
</pre>

<p>
5. Write the new layout to the device.
</p> 
<pre class="codeblock">
$ sudo /usr/bin/yafs -d /dev/sda1 -w -f fat_sorted.xml
</pre>

<p>
Note that <code>yafs</code> must be invoked as a full pathname,
so the utility can find its schema file in the same directory.
</p> 

<h2>Closing remarks</h2>

<p>
It's seems a little odd to me that, in 2022, there are still media
players that can't sort folders or play audio files in filename order. 
It's excusable, I guess, for a car radio or a pocket MP3 player, but
a little surprising in premium hifi equipment. 
</p>
<p>
Nevertheless, the procedure described in this article has made things
a lot more convenient. It's fiddly to set up but, once prepared, 
sorting the memory stick after changing its contents only takes a
second or two.
</p>
<p>
It would not be difficult, I think, to implement a FAT sorter that
sorted by alphanumeric order. It would even be
possible to set the filesystem order based on the track number in
the audio metadata, so we don't have to worry about numbering the tracks.
Still, the approach I've described here works well enough for my 
purposes, and doesn't require writing any new software.
</p>



<p><span class="footer-clearance-para"/></p>
</div>

<div id="footer">
<a href="rss.html"><img src="img/rss.png" width="24px" height="24px"/></a>
Categories: <a href="hifi-groupindex.html">hifi</a>, <a href="Linux-groupindex.html">Linux</a>

<span class="last-updated">Last update Sep 01 2022
</span>
</div>

</body>
</html>


